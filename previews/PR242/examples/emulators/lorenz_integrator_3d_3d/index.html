<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrating Lorenz 63 with an emulated integrator · CalibrateEmulateSample.jl</title><meta name="title" content="Integrating Lorenz 63 with an emulated integrator · CalibrateEmulateSample.jl"/><meta property="og:title" content="Integrating Lorenz 63 with an emulated integrator · CalibrateEmulateSample.jl"/><meta property="twitter:title" content="Integrating Lorenz 63 with an emulated integrator · CalibrateEmulateSample.jl"/><meta name="description" content="Documentation for CalibrateEmulateSample.jl."/><meta property="og:description" content="Documentation for CalibrateEmulateSample.jl."/><meta property="twitter:description" content="Documentation for CalibrateEmulateSample.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.svg" alt="CalibrateEmulateSample.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">CalibrateEmulateSample.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../../calibrate/">Calibrate</a></li><li><a class="tocitem" href="../../../emulate/">Emulate</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lorenz_example/">Lorenz example</a></li><li><a class="tocitem" href="../../edmf_example/">Turbulence example</a></li><li><a class="tocitem" href="../../Cloudy_example/">Cloudy example</a></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox" checked/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Emulator testing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../regression_2d_2d/">Regression of <span>$\mathbb{R}^2 \to \mathbb{R}^2$</span> smooth function</a></li><li class="is-active"><a class="tocitem" href>Integrating Lorenz 63 with an emulated integrator</a><ul class="internal"><li><a class="tocitem" href="#Walkthrough-of-the-code"><span>Walkthrough of the code</span></a></li><li><a class="tocitem" href="#Plots"><span>Plots</span></a></li></ul></li><li><a class="tocitem" href="../ishigami_3d_1d/">Global Sensitiviy Analysis for an emulated Ishigami function</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../GaussianProcessEmulator/">Gaussian Process</a></li><li><a class="tocitem" href="../../../random_feature_emulator/">Random Features</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Package Design</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../API/AbstractMCMC/">AbstractMCMC sampling API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">CalibrateEmulateSample</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1-1"><span class="docs-label">Emulators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../API/Emulators/">General Interface</a></li><li><a class="tocitem" href="../../../API/GaussianProcess/">Gaussian Process</a></li><li><a class="tocitem" href="../../../API/RandomFeatures/">Random Features</a></li></ul></li><li><a class="tocitem" href="../../../API/MarkovChainMonteCarlo/">MarkovChainMonteCarlo</a></li><li><a class="tocitem" href="../../../API/Utilities/">Utilities</a></li></ul></li></ul></li><li><a class="tocitem" href="../../../glossary/">Glossary</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Emulator testing</a></li><li class="is-active"><a href>Integrating Lorenz 63 with an emulated integrator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrating Lorenz 63 with an emulated integrator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/CalibrateEmulateSample.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/CalibrateEmulateSample.jl/blob/main/docs/src/examples/emulators/lorenz_integrator_3d_3d.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrating-Lorenz-63-with-an-emulated-integrator"><a class="docs-heading-anchor" href="#Integrating-Lorenz-63-with-an-emulated-integrator">Integrating Lorenz 63 with an emulated integrator</a><a id="Integrating-Lorenz-63-with-an-emulated-integrator-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-Lorenz-63-with-an-emulated-integrator" title="Permalink"></a></h1><p>In this example, we assess directly the performance of our machine learning emulators. The task is to learn the forward Euler integrator of a <a href="https://en.wikipedia.org/wiki/Lorenz_system">Lorenz 63 system</a>. The model parameters are set to their classical settings <span>$(\sigma, \rho, \beta) = (10,28,\frac{8}{3})$</span> to exhibit chaotic behavior. The discrete system is given as:</p><p class="math-container">\[\begin{aligned}
x(t_{n+1}) &amp;= x(t_n) + \Delta t(y(t_n) - x(t_n))\\
y(t_{n+1}) &amp;= y(t_n) + \Delta t(x(t_n)(28 - z(t_n)) - y(t_n))\\
z(t_{n+1}) &amp;= z(t_n) + \Delta t(x(t_n)y(t_n) - \frac{8}{3}z(t_n))
\end{aligned}\]</p><p>where <span>$t_n = n\Delta t$</span>. The data consists of pairs <span>$\{ (x(t_k),y(t_k),z(t_k)), (x(t_{k+1}),y(t_{k+1}),z(t_{k+1})+\eta_k\}$</span> for 600 values of <span>$k$</span>, with each output subjected to independent, additive Gaussian noise <span>$\eta_k\sim N(0,\Gamma_y)$</span>.</p><p>We have several different emulator configurations in this example that the user can play around with. The goal of the emulator is that the posterior mean will approximate this discrete update map, or integrator, for any point on the Lorenz attractor from the sparse noisy data. To validate this, we recursively apply the trained emulator to the state, plotting the evolution of the trajectory and marginal statistics of the states over short and long timescales. We include a repeats option (<code>n_repeats</code>) to run the randomized training for multiple trials and illustrate robustness of marginal statistics by plotting long time marginal cdfs of the state. </p><p>We will term scalar-output Gaussin process emulator as &quot;GP&quot;, and scalar- or vector-output random feature emulator as &quot;RF&quot;.</p><h2 id="Walkthrough-of-the-code"><a class="docs-heading-anchor" href="#Walkthrough-of-the-code">Walkthrough of the code</a><a id="Walkthrough-of-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough-of-the-code" title="Permalink"></a></h2><p>We first import some standard packages</p><pre><code class="language-julia hljs">using Random, Distributions, LinearAlgebra # utilities
using CairoMakie, ColorSchemes # for plots
using JLD2 # for saved data</code></pre><p>For the true integrator of the Lorenz system we import</p><pre><code class="language-julia hljs">using OrdinaryDiffEq </code></pre><p>For relevant CES packages needed to define the emulators, packages and kernel structures</p><pre><code class="language-julia hljs">using CalibrateEmulateSample.Emulators
# Contains `Emulator`, `GaussianProcess`, `ScalarRandomFeatureInterface`, `VectorRandomFeatureInterface`
# `GPJL`, `SeparablKernel`, `NonSeparableKernel`, `OneDimFactor`, `LowRankFactor`, `DiagonalFactor`
using CalibrateEmulateSample.DataContainers # Contains `PairedDataContainer`</code></pre><p>and if one wants to play with optimizer options for the random feature emulators we import</p><pre><code class="language-julia hljs">using CalibrateEmulateSample.EnsembleKalmanProcesses # Contains `DataMisfitController`</code></pre><p>We generate the truth data using <code>OrdinaryDiffEq</code>: the time series <code>sol</code> is used for training data, <code>sol_test</code> is used for plotting short time trajectories, and <code>sol_hist</code> for plotting histograms of the state over long times:</p><pre><code class="language-julia hljs"># Run L63 from 0 -&gt; tmax
u0 = [1.0; 0.0; 0.0]
tmax = 20
dt = 0.01
tspan = (0.0, tmax)
prob = ODEProblem(lorenz, u0, tspan)
sol = solve(prob, Euler(), dt = dt)

# Run L63 from end for test trajectory data
tmax_test = 100
tspan_test = (0.0, tmax_test)
u0_test = sol.u[end]
prob_test = ODEProblem(lorenz, u0_test, tspan_test)
sol_test = solve(prob_test, Euler(), dt = dt)

# Run L63 from end for histogram matching data
tmax_hist = 1000
tspan_hist = (0.0, tmax_hist)
u0_hist = sol_test.u[end]
prob_hist = ODEProblem(lorenz, u0_hist, tspan_hist)
sol_hist = solve(prob_hist, Euler(), dt = dt)</code></pre><p>We generate the training data from <code>sol</code> within <code>[tburn, tmax]</code>. The user has the option of how many training points to take <code>n_train_pts</code> and whether these are selected randomly or sequentially (<code>sample_rand</code>). The true outputs are perturbed by noise of variance <code>1e-4</code> and pairs are stored in the compatible data format <code>PairedDataContainer</code></p><pre><code class="language-julia hljs">tburn = 1 # NB works better with no spin-up!
burnin = Int(floor(tburn / dt))
n_train_pts = 600 
sample_rand = true
if sample_rand
   ind = Int.(shuffle!(rng, Vector(burnin:(tmax / dt - 1)))[1:n_train_pts])
else
   ind = burnin:(n_train_pts + burnin)
end
n_tp = length(ind)
input = zeros(3, n_tp)
output = zeros(3, n_tp)
Γy = 1e-4 * I(3)
noise = rand(rng, MvNormal(zeros(3), Γy), n_tp)
for i in 1:n_tp
    input[:, i] = sol.u[ind[i]]
    output[:, i] = sol.u[ind[i] + 1] + noise[:, i]
end
iopairs = PairedDataContainer(input, output)</code></pre><p>We have several cases the user can play with,</p><pre><code class="language-julia hljs">cases = [&quot;GP&quot;, &quot;RF-scalar&quot;, &quot;RF-scalar-diagin&quot;, &quot;RF-svd-nonsep&quot;, &quot;RF-nosvd-nonsep&quot;, &quot;RF-nosvd-sep&quot;]</code></pre><p>Then, looping over the repeats, we first define some common hyperparamter optimization options for the <code>&quot;RF-&quot;</code> cases. In this case, the options are used primarily for diagnostics and acceleration (not required in general to solve this problem) </p><pre><code class="language-julia hljs">rf_optimizer_overrides = Dict(
    &quot;verbose&quot; =&gt; true, # output diagnostics from the hyperparameter optimizer
    &quot;scheduler&quot; =&gt; DataMisfitController(terminate_at = 1e4), # timestepping method for the optimizer
    &quot;cov_sample_multiplier&quot; =&gt; 0.5, # 0.5*default number of samples to estimate covariances in optimizer
    &quot;n_features_opt&quot; =&gt; 200, # number of features during hyperparameter optimization
    &quot;n_iteration&quot; =&gt; 20, # iterations of the optimizer solver
)</code></pre><p>Then we build the machine learning tools. Here we highlight scalar-output Gaussian process (<code>GP</code>), where we use the default squared-exponential kernel, and learn a lengthscale hyperparameter in each input dimension. To handle multiple outputs, we will use a decorrelation in the output space, and so will actually train three of these models.</p><pre><code class="language-julia hljs">gppackage = Emulators.GPJL() # use GaussianProcesses.jl
pred_type = Emulators.YType() # predicted variances are for data not latent function
mlt = GaussianProcess(
    gppackage;
    prediction_type = pred_type,
    noise_learn = false, # do not additionally learn a white kernel
)</code></pre><p>we also highlight the Vector Random Feature with nonseparable kernel (<code>RF-nosvd-nonsep</code>), this can natively handle multiple outputs without decorrelation of the output space. This kernel is a rank-3 representation with small nugget term.</p><pre><code class="language-julia hljs">nugget = 1e-12
kernel_structure = NonseparableKernel(LowRankFactor(3, nugget))
n_features = 500 # number of features for prediction
mlt = VectorRandomFeatureInterface(
    n_features,
    3, # input dimension
    3, # output dimension
    rng = rng, # pin random number generator
    kernel_structure = kernel_structure,
    optimizer_options = rf_optimizer_overrides, 
)           </code></pre><p>With machine learning tools specified, we build the emulator object</p><pre><code class="language-julia hljs"># decorrelate = true for `GP`
# decorrelate = false for `RF-nosvd-nonsep`
emulator = Emulator(mlt, iopairs; obs_noise_cov = Γy, decorrelate = decorrelate) 
optimize_hyperparameters!(emulator) # some GP packages require this additional call </code></pre><h2 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h2><p>We predict the trained emulator mean, over the short-timescale validation trajectory</p><pre><code class="language-julia hljs">u_test_tmp = zeros(3, length(xspan_test))
u_test_tmp[:, 1] = sol_test.u[1] # initialize at the final-time solution of the training period

for i in 1:(length(xspan_test) - 1)
    rf_mean, _ = predict(emulator, u_test_tmp[:, i:i], transform_to_real = true) # 3x1 matrix
    u_test_tmp[:, i + 1] = rf_mean
end</code></pre><p>The other trajectories are similar. We then produce the following plots. In all figures, the results from evolving the state with the true integrator is orange, and with the emulated integrators are blue.</p><h3 id="Gaussian-Process-Emulator-(Sci-kit-learn:-GP)"><a class="docs-heading-anchor" href="#Gaussian-Process-Emulator-(Sci-kit-learn:-GP)">Gaussian Process Emulator (Sci-kit learn: <code>GP</code>)</a><a id="Gaussian-Process-Emulator-(Sci-kit-learn:-GP)-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Process-Emulator-(Sci-kit-learn:-GP)" title="Permalink"></a></h3><p>For one example fit</p><img src="../../../assets/GP_l63_test.png" width="600">
<img src="../../../assets/GP_l63_attr.png" width="300"><img src="../../../assets/GP_l63_pdf.png" width="300"><h3 id="Random-Feature-Emulator-(RF-nosvd-nonsep)"><a class="docs-heading-anchor" href="#Random-Feature-Emulator-(RF-nosvd-nonsep)">Random Feature Emulator (<code>RF-nosvd-nonsep</code>)</a><a id="Random-Feature-Emulator-(RF-nosvd-nonsep)-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Feature-Emulator-(RF-nosvd-nonsep)" title="Permalink"></a></h3><p>For one example fit</p><img src="../../../assets/RF-nosvd-nonsep_l63_test.png" width="600">
<img src="../../../assets/RF-nosvd-nonsep_l63_attr.png" width="300"><img src="../../../assets/RF-nosvd-nonsep_l63_pdf.png" width="300"><p>and here are CDFs over 20 randomized trials of the random feature hyperparameter optimization</p><img src="../../../assets/RF-nosvd-nonsep_l63_cdfs.png" width="600"></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../regression_2d_2d/">« Regression of <span>$\mathbb{R}^2 \to \mathbb{R}^2$</span> smooth function</a><a class="docs-footer-nextpage" href="../ishigami_3d_1d/">Global Sensitiviy Analysis for an emulated Ishigami function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 2 January 2024 13:21">Tuesday 2 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
