<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lorenz example · CalibrateEmulateSample.jl</title><meta name="title" content="Lorenz example · CalibrateEmulateSample.jl"/><meta property="og:title" content="Lorenz example · CalibrateEmulateSample.jl"/><meta property="twitter:title" content="Lorenz example · CalibrateEmulateSample.jl"/><meta name="description" content="Documentation for CalibrateEmulateSample.jl."/><meta property="og:description" content="Documentation for CalibrateEmulateSample.jl."/><meta property="twitter:description" content="Documentation for CalibrateEmulateSample.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="CalibrateEmulateSample.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CalibrateEmulateSample.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sinusoid_example/">Simple example walkthrough</a></li><li class="is-active"><a class="tocitem" href>Lorenz example</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Structure"><span>Structure</span></a></li><li class="toplevel"><a class="tocitem" href="#Walkthrough-of-the-code"><span>Walkthrough of the code</span></a></li><li><a class="tocitem" href="#Inputs"><span>Inputs</span></a></li><li><a class="tocitem" href="#Calibrate"><span>Calibrate</span></a></li><li><a class="tocitem" href="#Emulate"><span>Emulate</span></a></li><li><a class="tocitem" href="#Sample"><span>Sample</span></a></li><li class="toplevel"><a class="tocitem" href="#Running-the-Example-and-Postprocessing"><span>Running the Example and Postprocessing</span></a></li><li><a class="tocitem" href="#Calibrate-2"><span>Calibrate</span></a></li><li><a class="tocitem" href="#Emulate-sample"><span>Emulate-sample</span></a></li><li class="toplevel"><a class="tocitem" href="#L96-CES-example-case:-GP-regression-emulator-(case&quot;GP&quot;)"><span>L96 CES example case: GP regression emulator (case=&quot;GP&quot;)</span></a></li><li class="toplevel"><a class="tocitem" href="#L96-CES-example-case:-RF-scalar-emulator-(case&quot;RF-scalar&quot;)"><span>L96 CES example case: RF scalar emulator (case=&quot;RF-scalar&quot;)</span></a></li></ul></li><li><a class="tocitem" href="../edmf_example/">Turbulence example</a></li><li><a class="tocitem" href="../Cloudy_example/">Cloudy example</a></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Emulator testing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../emulators/regression_2d_2d/">Regression of <span>$\mathbb{R}^2 \to \mathbb{R}^2$</span> smooth function</a></li><li><a class="tocitem" href="../emulators/lorenz_integrator_3d_3d/">Integrating Lorenz 63 with an emulated integrator</a></li><li><a class="tocitem" href="../emulators/ishigami_3d_1d/">Global Sensitiviy Analysis for an emulated Ishigami function</a></li></ul></li></ul></li><li><a class="tocitem" href="../../calibrate/">Calibrate</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Emulate</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../emulate/">Emulator</a></li><li><a class="tocitem" href="../../GaussianProcessEmulator/">Gaussian Process</a></li><li><a class="tocitem" href="../../random_feature_emulator/">Random Features</a></li></ul></li><li><a class="tocitem" href="../../sample/">Sample</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">CalibrateEmulateSample</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1-1"><span class="docs-label">Emulators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../API/Emulators/">General Interface</a></li><li><a class="tocitem" href="../../API/GaussianProcess/">Gaussian Process</a></li><li><a class="tocitem" href="../../API/RandomFeatures/">Random Features</a></li></ul></li><li><a class="tocitem" href="../../API/MarkovChainMonteCarlo/">MarkovChainMonteCarlo</a></li><li><a class="tocitem" href="../../API/Utilities/">Utilities</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Lorenz example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lorenz example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/CalibrateEmulateSample.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/CalibrateEmulateSample.jl/blob/main/docs/src/examples/lorenz_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lorenz-96-example"><a class="docs-heading-anchor" href="#Lorenz-96-example">Lorenz 96 example</a><a id="Lorenz-96-example-1"></a><a class="docs-heading-anchor-permalink" href="#Lorenz-96-example" title="Permalink"></a></h1><p>The Lorenz 96 (hereafter L96) example is a toy-problem for the application of the <code>CalibrateEmulateSample.jl</code> optimization and approximate uncertainty quantification methodologies. Here is L96 with additional periodic-in-time forcing, we try to determine parameters (sinusoidal amplitude and stationary component of the forcing) from some output statistics. The standard L96 equations are implemented with an additional forcing term with time dependence. The output statistics which are used for learning are the finite time-averaged variances.</p><p>The standard single-scale L96 equations are implemented. The Lorenz 96 system (<a href="http://www.raidl.cz/file/18/lorenz-1996-_predictability_partly_solved.pdf">Lorenz, 1996</a>) is given by </p><p class="math-container">\[\frac{d x_i}{d t} = (x_{i+1} - x_{i-2}) x_{i-1} - x_i + F,\]</p><p>with <span>$i$</span> indicating the index of the given longitude. The number of longitudes is given by <span>$N$</span>. The boundary conditions are given by</p><p class="math-container">\[x_{-1} = x_{N-1}, \ x_0 = x_N, \ x_{N+1} = x_1.\]</p><p>The time scaling is such that the characteristic time is 5 days (<a href="http://www.raidl.cz/file/18/lorenz-1996-_predictability_partly_solved.pdf">Lorenz, 1996</a>).  For very small values of <span>$F$</span>, the solutions <span>$x_i$</span> decay to <span>$F$</span> after the initial transient feature. For moderate values of <span>$F$</span>, the solutions are periodic, and for larger values of <span>$F$</span>, the system is chaotic. The solution variance is a function of the forcing magnitude. Variations in the base state as a function of time can be imposed through a time-dependent forcing term <span>$F(t)$</span>.</p><p>A temporal forcing term is defined</p><p class="math-container">\[F = F_s + A \sin(\omega t),\]</p><p>with steady-state forcing <span>$F_s$</span>, transient forcing amplitude <span>$A$</span>, and transient forcing frequency <span>$\omega$</span>. The total forcing <span>$F$</span> must be within the chaotic regime of L96 for all time given the prescribed <span>$N$</span>.</p><p>The L96 dynamics are solved with RK4 integration.</p><h1 id="Structure"><a class="docs-heading-anchor" href="#Structure">Structure</a><a id="Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Structure" title="Permalink"></a></h1><p>The example is structured with two distinct components: 1) L96 dynamical system solver; 2) calibrate-emulate sample code. Each of these are described below.</p><p>The forward mapping from input parameters to output statistics of the L96 system is solved using the <code>GModel.jl</code> code, which runs the L96 model across different input parameters <span>$\theta$</span>. The source code for the L96 system solution is within the <code>GModel_common.jl</code> code. </p><p>The Calibrate code is located in <code>calibrate.jl</code> which provides the functionality to run the L96 dynamical system (within the <code>GModel.jl</code> code), extract time-averaged statistics from the L96 states, and use the time-average statistics for calibration. While this example description is self-contained, there is an additional description of the use of <code>EnsembleKalmanProcesses.jl</code> for the L96 example that is accessible <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/examples/lorenz_example/">here</a>.</p><p>The Emulate-Sample code is located in <code>emulate_sample.jl</code> which provides the functionality to use the input-output pairs from the Calibrate stage for emulation and sampling (uncertainty quantification). The <code>emulate_sample.jl</code> code relies on outputs from the <code>calibrate.jl</code> code</p><h1 id="Walkthrough-of-the-code"><a class="docs-heading-anchor" href="#Walkthrough-of-the-code">Walkthrough of the code</a><a id="Walkthrough-of-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough-of-the-code" title="Permalink"></a></h1><p>This walkthrough covers calibrate-emulate-sample for the L96 problem defined above. The goal is to learn parameters <code>F_s</code> and <code>A</code> based on the time averaged statistics in a perfect model setting. This document focuses on the emulate-sample (<code>emulate_sample.jl</code>) stages, but discussion of the calibration stage <code>calibrate.jl</code> are made when necessary. This code relies on data generated by first running <code>calibrate.jl</code>. A detailed walkthrough of the calibration stage of CES for the L96 example is available <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/examples/lorenz_example/">here</a>. </p><h2 id="Inputs"><a class="docs-heading-anchor" href="#Inputs">Inputs</a><a id="Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Inputs" title="Permalink"></a></h2><p>First, we load standard packages</p><pre><code class="language-julia hljs"># Import modules
using Distributions  # probability distributions and associated functions
using LinearAlgebra
using StatsPlots
using Plots
using Random
using JLD2</code></pre><p>Then, we load <code>CalibrateEmulateSample.jl</code> packages</p><pre><code class="language-julia hljs"># CES 
using CalibrateEmulateSample.Emulators
using CalibrateEmulateSample.MarkovChainMonteCarlo
using CalibrateEmulateSample.Utilities
using CalibrateEmulateSample.EnsembleKalmanProcesses
using CalibrateEmulateSample.ParameterDistributions
using CalibrateEmulateSample.DataContainers
using CalibrateEmulateSample.Observations</code></pre><p>The first input settings define which input-output pairs to use for training the emulator. The Calibrate stage (run using <code>calibrate.jl</code>) generates parameter-to-data pairs by running the L96 system using an iterative optimization approach (<code>EnsembleKalmanProcess.jl</code>). So we first define which iterations we would like to use data from for our emulator training</p><pre><code class="language-julia hljs">min_iter = 1
max_iter = 5 # number of EKP iterations to use data from is at most this</code></pre><p>The second input settings define the Lorenz dynamics. The <code>emulate_sample.jl</code> code does not actually run the L96 system, it only uses L96 system runs from the <code>calibrate.jl</code> stage to train an emulator and to perform sampling. Therefore, the settings governing the L96 dynamics are fully defined in <code>calibrate.jl</code> and can be modified as necessary. The rest of the input settings in this section are defined in <code>calibrate.jl</code>. </p><pre><code class="language-julia hljs">F_true = 8.0 # Mean F
A_true = 2.5 # Transient F amplitude
ω_true = 2.0 * π / (360.0 / τc) # Frequency of the transient F (non-dim)
params_true = [F_true, A_true]
param_names = [&quot;F&quot;, &quot;A&quot;]</code></pre><p>The use of the transient forcing term is with the flag, <code>dynamics</code>. Stationary forcing is <code>dynamics=1</code> (<span>$A=0$</span>) and transient forcing is used with <code>dynamics=2</code> (<span>$A\neq0$</span>). The system with <span>$N$</span> longitudes is solved over time horizon <code>t_start</code> to <code>Tfit</code> at fixed time step <code>dt</code>.</p><pre><code class="language-julia hljs">N = 36
dt = 1/64
t_start = 100
# Characteristic time scale
τc = 5.0 # days, prescribed by the L96 problem
# This has to be less than 360 and 360 must be divisible by Ts_days
Ts_days = 30.0 # Integration length in days (will be made non-dimensional later)
# Integration length
Tfit = Ts_days / τc</code></pre><p>The states are integrated over time <code>Ts_days</code> to construct the time averaged statistics for use by the Ensemble Kalman Process calibration. The specification of the statistics to be gathered from the states are provided by <code>stats_type</code>.</p><p>We implement (biased) priors as follows</p><pre><code class="language-julia hljs">prior_means = [F_true + 1.0, A_true + 0.5]
prior_stds = [2.0, 0.5 * A_true]
# constrained_gaussian(&quot;name&quot;, desired_mean, desired_std, lower_bd, upper_bd)
prior_F = constrained_gaussian(param_names[1], prior_means[1], prior_stds[1], 0, Inf)
prior_A = constrained_gaussian(param_names[2], prior_means[2], prior_stds[2], 0, Inf)
priors = combine_distributions([prior_F, prior_A])</code></pre><p>We use the recommended [<code>constrained_gaussian</code>] to add the desired scale and bounds to the prior distribution, in particular we place lower bounds to preserve positivity. </p><p>The priors can be plotted directly using <code>plot(priors)</code>, as seen below in the example code from <code>calibrate.jl</code></p><pre><code class="language-julia hljs"># Plot the prior distribution
p = plot(priors, title = &quot;prior&quot;)
plot!(p.subplots[1], [F_true], seriestype = &quot;vline&quot;, w = 1.5, c = :steelblue, ls = :dash, xlabel = &quot;F&quot;) # vline on top histogram
plot!(p.subplots[2], [A_true], seriestype = &quot;vline&quot;, w = 1.5, c = :steelblue, ls = :dash, xlabel = &quot;A&quot;) # vline on top histogram</code></pre><img src="../../assets/Lorenz-prior.png" width="600"><p>The observational noise can be generated using the L96 system or prescribed, as specified by <code>var_prescribe</code>.  <code>var_prescribe==false</code> The observational noise is constructed by generating independent instantiations of the L96 statistics of interest at the true parameters for different initial conditions. The empirical covariance matrix is constructed.</p><p><code>var_prescribe==true</code> The observational noise is prescribed as a Gaussian distribution with prescribed mean and variance.</p><h2 id="Calibrate"><a class="docs-heading-anchor" href="#Calibrate">Calibrate</a><a id="Calibrate-1"></a><a class="docs-heading-anchor-permalink" href="#Calibrate" title="Permalink"></a></h2><p>The calibration stage must be run before the emulate-sample stages. The calibration stage is run using <code>calibrate.jl</code>. This code will generate parameter-data pairs that will be used to train the emulator. The parameter-data pairs are visualized below</p><img src="../../assets/Lorenz-training-points.png" width="600"><h2 id="Emulate"><a class="docs-heading-anchor" href="#Emulate">Emulate</a><a id="Emulate-1"></a><a class="docs-heading-anchor-permalink" href="#Emulate" title="Permalink"></a></h2><p>Having run the <code>calibrate.jl</code> code to generate input-output pairs from parameters to data using <code>EnsembleKalmanProcesses.jl</code>, we will now run the Emulate and Sample stages (emulate_sample.jl`). First, we need to define which machine learning model we will use for the emulation. We have 8 cases that the user can toggle or customize</p><pre><code class="language-julia hljs">cases = [
        &quot;GP&quot;, # diagonalize, train scalar GP, assume diag inputs
        &quot;RF-scalar-diagin&quot;, # diagonalize, train scalar RF, assume diag inputs (most comparable to GP)
        &quot;RF-scalar&quot;, # diagonalize, train scalar RF, do not asume diag inputs
        &quot;RF-vector-svd-diag&quot;,
        &quot;RF-vector-svd-nondiag&quot;,
        &quot;RF-vector-nosvd-diag&quot;,
        &quot;RF-vector-nosvd-nondiag&quot;,
        &quot;RF-vector-svd-nonsep&quot;,
]</code></pre><p>The first is for GP with <code>GaussianProcesses.jl</code> interface. The next two are for the scalar RF interface, which most closely follows exactly replacing a GP. The rest are examples of vector RF with different types of data processing, (svd = same processing as scalar RF, nosvd = unprocessed) and different RF kernel structures in the output space of increasing complexity/flexibility (diag = Separable diagonal, nondiag = Separable nondiagonal, nonsep = nonseparable nondiagonal).</p><p>The example then loads the relevant training data that was constructed in the <code>calibrate.jl</code> call. </p><pre><code class="language-julia hljs"># loading relevant data
homedir = pwd()
println(homedir)
figure_save_directory = joinpath(homedir, &quot;output/&quot;)
data_save_directory = joinpath(homedir, &quot;output/&quot;)
data_save_file = joinpath(data_save_directory, &quot;calibrate_results.jld2&quot;)
ekiobj = load(data_save_file)[&quot;eki&quot;]
priors = load(data_save_file)[&quot;priors&quot;]
truth_sample_mean = load(data_save_file)[&quot;truth_sample_mean&quot;]
truth_sample = load(data_save_file)[&quot;truth_sample&quot;]
truth_params_constrained = load(data_save_file)[&quot;truth_input_constrained&quot;] #true parameters in constrained space
truth_params = transform_constrained_to_unconstrained(priors, truth_params_constrained)
Γy = ekiobj.obs_noise_cov</code></pre><p>We then set up the structure of the emulator. An example for GP (<code>GP</code>)</p><pre><code class="language-julia hljs">gppackage = Emulators.GPJL()
pred_type = Emulators.YType()
mlt = GaussianProcess(
    gppackage;
    kernel = nothing, # use default squared exponential kernel
    prediction_type = pred_type,
    noise_learn = false,
)</code></pre><p>which calls <code>GaussianProcess.jl</code>. In this L96 example, since we focus on learning <span>$F_s$</span> and <span>$A$</span>, we do not need to explicitly learn the noise, so <code>noise_learn = false</code>.</p><p>An example for scalar RF (<code>RF-scalar</code>)</p><pre><code class="language-julia hljs">n_features = 100
kernel_structure = SeparableKernel(LowRankFactor(2, nugget), OneDimFactor())
mlt = ScalarRandomFeatureInterface(
    n_features,
    n_params,
    rng = rng,
    kernel_structure = kernel_structure,
    optimizer_options = overrides,
)</code></pre><p>Optimizer options for <code>ScalarRandomFeature.jl</code> are provided throough <code>overrides</code></p><pre><code class="language-julia hljs">overrides = Dict(
            &quot;verbose&quot; =&gt; true,
            &quot;scheduler&quot; =&gt; DataMisfitController(terminate_at = 100.0),
            &quot;cov_sample_multiplier&quot; =&gt; 1.0,
            &quot;n_iteration&quot; =&gt; 20,
        )
# we do not want termination, as our priors have relatively little interpretation</code></pre><p>We then build the emulator with the parameters as defined above</p><pre><code class="language-julia hljs">emulator = Emulator(
            mlt,
            input_output_pairs;
            obs_noise_cov = Γy,
            normalize_inputs = normalized,
            standardize_outputs = standardize,
            standardize_outputs_factors = norm_factor,
            retained_svd_frac = retained_svd_frac,
            decorrelate = decorrelate,
        )</code></pre><p>For RF and some GP packages, the training occurs during construction of the Emulator, however sometimes one must call an optimize step afterwards</p><pre><code class="language-julia hljs">optimize_hyperparameters!(emulator)</code></pre><p>The emulator is checked for accuracy by evaluating its predictions on the true parameters</p><pre><code class="language-julia hljs"># Check how well the Gaussian Process regression predicts on the
# true parameters
y_mean, y_var = Emulators.predict(emulator, reshape(truth_params, :, 1), transform_to_real = true)
y_mean_test, y_var_test = Emulators.predict(emulator, get_inputs(input_output_pairs_test), transform_to_real = true)

println(&quot;ML prediction on true parameters: &quot;)
println(vec(y_mean))
println(&quot;true data: &quot;)
println(truth_sample) # what was used as truth
println(&quot; ML predicted standard deviation&quot;)
println(sqrt.(diag(y_var[1], 0)))
println(&quot;ML MSE (truth): &quot;)
println(mean((truth_sample - vec(y_mean)) .^ 2))
println(&quot;ML MSE (next ensemble): &quot;)
println(mean((get_outputs(input_output_pairs_test) - y_mean_test) .^ 2))</code></pre><h2 id="Sample"><a class="docs-heading-anchor" href="#Sample">Sample</a><a id="Sample-1"></a><a class="docs-heading-anchor-permalink" href="#Sample" title="Permalink"></a></h2><p>Now the emulator is constructed and validated, so we next focus on the MCMC sampling. First, we run a short chain (<span>$2,000$</span> steps) to determine the step size</p><pre><code class="language-julia hljs"># First lets run a short chain to determine a good step size
mcmc = MCMCWrapper(RWMHSampling(), truth_sample, priors, emulator; init_params = u0)
new_step = optimize_stepsize(mcmc; init_stepsize = 0.1, N = 2000, discard_initial = 0)</code></pre><p>The step size has been determined, so now we run the full MCMC (<span>$100,000$</span> steps where the first <span>$2,000$</span> are discarded)</p><pre><code class="language-julia hljs"># Now begin the actual MCMC
println(&quot;Begin MCMC - with step size &quot;, new_step)
chain = MarkovChainMonteCarlo.sample(mcmc, 100_000; stepsize = new_step, discard_initial = 2_000)</code></pre><p>And we finish by extracting the posterior samples</p><pre><code class="language-julia hljs">posterior = MarkovChainMonteCarlo.get_posterior(mcmc, chain)</code></pre><p>And evaluate the results with these printed statements</p><pre><code class="language-julia hljs">post_mean = mean(posterior)
post_cov = cov(posterior)
println(&quot;post_mean&quot;)
println(post_mean)
println(&quot;post_cov&quot;)
println(post_cov)
println(&quot;D util&quot;)
println(det(inv(post_cov)))
println(&quot; &quot;)</code></pre><h1 id="Running-the-Example-and-Postprocessing"><a class="docs-heading-anchor" href="#Running-the-Example-and-Postprocessing">Running the Example and Postprocessing</a><a id="Running-the-Example-and-Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-Example-and-Postprocessing" title="Permalink"></a></h1><p>First, the calibrate code must be executed, which will perform the calibration step and, generating input-output pairs of the parameter to data mapping. Then, the emulate-sample code is run, which will load the input-ouput pairs that were generated in the calibration step.</p><h2 id="Calibrate-2"><a class="docs-heading-anchor" href="#Calibrate-2">Calibrate</a><a class="docs-heading-anchor-permalink" href="#Calibrate-2" title="Permalink"></a></h2><p>The L96 parameter calibration can be run using <code>julia --project calibrate.jl</code></p><p>The output will provide the estimated parameters in the constrained <code>ϕ</code>-space. The <code>priors</code> are required in the get-method to apply these constraints.</p><p>Printed output:</p><pre><code class="language-julia hljs"># EKI results: Has the ensemble collapsed toward the truth?
println(&quot;True parameters: &quot;)
println(params_true)
println(&quot;\nEKI results:&quot;)
println(get_ϕ_mean_final(priors, ekiobj))</code></pre><p>The parameters and forward model outputs will be saved in <code>parameter_storage.jld2</code> and <code>data_storage.jld2</code>, respectively. The data will be saved in the directory <code>output</code>. A scatter plot animation of the ensemble convergence to the true parameters is saved in the directory <code>output</code>. These points represent the training points that are used for the emulator.</p><img src="../../assets/Lorenz-training-points.png" width="600"><h2 id="Emulate-sample"><a class="docs-heading-anchor" href="#Emulate-sample">Emulate-sample</a><a id="Emulate-sample-1"></a><a class="docs-heading-anchor-permalink" href="#Emulate-sample" title="Permalink"></a></h2><p>The L96 parameter estimation can be run using <code>julia --project emulate_sample.jl</code></p><p>The output will provide the estimated posterior distribution over the parameters. The emulate-sample code will run for several choices in the machine learning model that is used for the emulation stage, inclding Gaussian Process regression and RF, and using singular value data decorrelation or not. </p><p>The sampling results from two emulators are shown below. We can see that the posterior is relatively insensitive to the choice of the machine learning emulation tool in this L96 example.</p><h1 id="L96-CES-example-case:-GP-regression-emulator-(case&quot;GP&quot;)"><a class="docs-heading-anchor" href="#L96-CES-example-case:-GP-regression-emulator-(case&quot;GP&quot;)">L96 CES example case: GP regression emulator (case=&quot;GP&quot;)</a><a id="L96-CES-example-case:-GP-regression-emulator-(case&quot;GP&quot;)-1"></a><a class="docs-heading-anchor-permalink" href="#L96-CES-example-case:-GP-regression-emulator-(case&quot;GP&quot;)" title="Permalink"></a></h1><img src="../../assets/Lorenz-posterior.png" width="600"><h1 id="L96-CES-example-case:-RF-scalar-emulator-(case&quot;RF-scalar&quot;)"><a class="docs-heading-anchor" href="#L96-CES-example-case:-RF-scalar-emulator-(case&quot;RF-scalar&quot;)">L96 CES example case: RF scalar emulator (case=&quot;RF-scalar&quot;)</a><a id="L96-CES-example-case:-RF-scalar-emulator-(case&quot;RF-scalar&quot;)-1"></a><a class="docs-heading-anchor-permalink" href="#L96-CES-example-case:-RF-scalar-emulator-(case&quot;RF-scalar&quot;)" title="Permalink"></a></h1><img src="../../assets/Lorenz-posterior-RF.png" width="600"></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sinusoid_example/">« Simple example walkthrough</a><a class="docs-footer-nextpage" href="../edmf_example/">Turbulence example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 19 March 2024 18:12">Tuesday 19 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
