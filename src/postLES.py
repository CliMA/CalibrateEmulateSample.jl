# -*- coding: utf-8 -*-
# Ignacio Lopez Gomez
# July 2018
# Post-processing tools for BL simulations with PyCLES
# This script should be located in the same directory as the Output 
# folders generated by PyCLES.

import data_tools as tl
import numpy as np
import scipy.interpolate as interp

def ensemble(f_t_z):
    # Time-average of f(t,z) over the period in which it is defined.
    # Taken as ensemble average assuming ergodic hypothesis.    
    i = 0; ensf_z=[]
    # Number of timesteps
    num_timesteps = int(np.size(f_t_z)/len(f_t_z[:][0]))
    # i is the spatial variable (z)
    while (i<len(f_t_z[0][:])):
        aux = 0.; j=0;
        # j is the time variable
        while (j<num_timesteps):
            aux += f_t_z[j][i]
            j += 1            
        ensf_z.append(aux/float(num_timesteps))
        i += 1
    return ensf_z

def temp_variance(f_t_z):
    # Time-variance of f(t,z) over the period in which it is defined.
    temp_mean = ensemble(f_t_z)
    num_timesteps = int(np.size(f_t_z)/len(f_t_z[:][0]))
    
    i=0;
    while (i<len(f_t_z[0][:])):
        j=0;
        # j is the time variable
        while (j<num_timesteps): 
            f_t_z[j][i] *= f_t_z[j][i]
            j += 1
        i += 1
    temp_var = ensemble(f_t_z)
    i=0;
    while (i<len(f_t_z[0][:])):
        temp_var[i] = temp_var[i] - temp_mean[i]*temp_mean[i]
        i += 1

    return temp_var


def vert_int(sim, f_t_z, useTrapz=False):
    # Vertical integral of f(t,z) for all t, defined for homogeneous grids.
    # Output: F(t). Units are [F] = [f] * length
    print('Hello world')
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    dz = z[1]-z[0]
    j = 0; ensf_z=[]
    index2 = int(np.size(f_t_z)/len(f_t_z[0, :]))
    # j is the time variable
    while (j<index2):
        aux = 0.; i=0;
        # i is the space variable
        if useTrapz:
            ensf_z.append(np.trapz(f_t_z[j, :], dx=dz))
        else:
            while (i<len(f_t_z[0, :])):
                aux += f_t_z[j, i]
                i += 1            
            ensf_z.append(dz*aux)
        j += 1
    return ensf_z

def getVariable(sim, variable):
    
    # Note that this function is defined for variables located at cell center heights (not w).
    t = tl.ncFetch(sim,'stats','profiles', 't')[:]
    if "w_mean" in variable:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    var = tl.ncFetch(sim,'stats', 'profiles', variable)[:][:]
    return t, z, var
    
def getProfile(sim, variable, ti=-1, tf=-1, getFullHeights=False):
    # Instantaneous or time-averaged profile of a variable with z.
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    if "w_mean" in variable or getFullHeights:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        var = tl.ncFetch(sim,'stats', 'profiles', variable)[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        var = tl.ncFetch(sim,'stats', 'profiles', variable)\
        [index][:]
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
    
        var_list = tl.ncFetch(sim,'stats','profiles', variable)\
            [init_index:final_index][:]
            
        var = ensemble(var_list)
    return var, z

def getTimeseries(sim, varname, ti=-1, tf=-1):
    # Instantaneous vertically-integrated TKE for all t.
    
    # Input: Simulation.
    
    # Output: Time series of vertically-integrated TKE and t.
    t = tl.ncFetch(sim,'stats','profiles', 't')[:]
    if (ti<0 and tf<0):
        var = tl.ncFetch(sim,'stats', 'timeseries', varname)[:]
    elif (ti>0 and tf>0): 
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
        t = tl.ncFetch(sim,'stats','profiles', 't')[init_index:final_index]
        var = tl.ncFetch(sim,'stats','timeseries', varname)\
            [init_index:final_index]
    return t, var

def getRef(sim, varname):

    if "half" in varname:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    elif "temperature" in varname:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    elif "q" in varname:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]

    var = tl.ncFetch(sim,'stats', 'reference', varname)[:]
        
    return var, z

def getTimeEv_z(sim, variable, z0):
    # Instantaneous or time-averaged profile of a variable with z.
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    if "w_mean" in variable:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]

    dz = z[1]-z[0]
    index = int(round((z0)/dz))
    t = tl.ncFetch(sim,'stats','profiles', 't')[:]
    var_list = tl.ncFetch(sim,'stats','profiles', variable)\
            [:][:]
    var = [0]*len(t)
    i=0
    while(i<len(t)):
        var[i]= var_list[i][index]
        i += 1
    return t, var

def getCovariance(sim, var1, var2, vars_product, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]

    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    z_face = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    
    if (ti<0 and tf<0):
        v1v2 = tl.ncFetch(sim,'stats','profiles', vars_product)[-1][:]    
        v1 = tl.ncFetch(sim,'stats','profiles', var1)[-1][:]
        v2 = tl.ncFetch(sim,'stats','profiles', var2)[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        v1v2 = tl.ncFetch(sim,'stats','profiles', vars_product)[index][:]    
        v1 = tl.ncFetch(sim,'stats','profiles', var1)[index][:]
        v2 = tl.ncFetch(sim,'stats','profiles', var2)[index][:]
    
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        v1v2_list = tl.ncFetch(sim,'stats','profiles', vars_product)\
            [init_index:final_index][:]
        v1_list = tl.ncFetch(sim,'stats','profiles', var1)\
            [init_index:final_index][:]
        v2_list = tl.ncFetch(sim,'stats','profiles', var2)\
            [init_index:final_index][:]
        
        v1v2 = ensemble(v1v2_list)
        v1 = ensemble(v1_list)
        v2 = ensemble(v2_list)
        
    if "w_mean" in var1:
        v1 = np.interp(z, z_face, v1)
    elif "w_mean" in var2:
        v2 = np.interp(z, z_face, v2)
        
    i=0; v1v2covar= [0]*len(z);
    while (i<len(z)):
        v1v2covar[i] = v1v2[i] - v1[i]*v2[i]
        i += 1
        
    return z, v1v2covar

def time_stats_prof(sim, variable, ti, tf, normalize=False):
    
    if "w_mean" in variable:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]

    t = tl.ncFetch(sim,'stats','profiles', 't')[:]
    dt = t[1]-t[0]
    init_index = int(round((ti-t[0])/dt) + 1)
    final_index = int(round((tf-t[0])/dt))

    var_list = tl.ncFetch(sim,'stats','profiles', variable)\
        [init_index:final_index][:]
        
    temp_avg = ensemble(var_list)
    temp_var = temp_variance(var_list)
    if normalize:
        i=0
        while(i<len(temp_var)):
            temp_var[i] = np.sqrt(temp_var[i])
            i += 1
    return z, temp_avg, temp_var

def getVariance(sim, variable, ti=-1, tf=-1):
    
    if "w_mean" in variable:
    	z = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    else:
    	z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]

    if (ti<0 and tf<0):
        varvar = tl.ncFetch(sim,'stats','profiles', ''.join((variable, '2')))[-1][:]
        var = tl.ncFetch(sim,'stats','profiles', variable)[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        varvar = tl.ncFetch(sim,'stats','profiles', ''.join((variable, '2')))[index][:]        
        var = tl.ncFetch(sim,'stats','profiles', variable)[index][:]
                
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        varvar_list = tl.ncFetch(sim,'stats','profiles', ''.join((variable, '2')))\
            [init_index:final_index][:]
        
        varvar = ensemble(varvar_list)
        
        var_list = tl.ncFetch(sim,'stats','profiles', variable)\
            [init_index:final_index][:]
        
        var = ensemble(var_list)
        
    i=0; variance= [0]*len(z);
    while (i<len(z)):
        variance[i] = varvar[i] - var[i]*var[i]
        i += 1
        
    return variance, z

def vel_variances(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    z_face = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    if (ti<0 and tf<0):
        ww_face = tl.ncFetch(sim,'stats','profiles', 'w_mean2')[-1][:]
        ww = np.interp(z, z_face, ww_face)
        uu = tl.ncFetch(sim,'stats','profiles', 'u_mean2')[-1][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'v_mean2')[-1][:]
        
        w_face = tl.ncFetch(sim,'stats','profiles', 'w_mean')[-1][:]
        w = np.interp(z, z_face, w_face)
        u = tl.ncFetch(sim,'stats','profiles', 'u_mean')[-1][:]
        v = tl.ncFetch(sim,'stats','profiles', 'v_mean')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        ww_face = tl.ncFetch(sim,'stats','profiles', 'w_mean2')[index][:]
        ww = np.interp(z, z_face, ww_face)
        uu = tl.ncFetch(sim,'stats','profiles', 'u_mean2')[index][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'v_mean2')[index][:]
        
        w_face = tl.ncFetch(sim,'stats','profiles', 'w_mean')[index][:]
        w = np.interp(z, z_face, w_face)
        u = tl.ncFetch(sim,'stats','profiles', 'u_mean')[index][:]
        v = tl.ncFetch(sim,'stats','profiles', 'v_mean')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        ww_list = tl.ncFetch(sim,'stats','profiles', 'w_mean2')\
            [init_index:final_index][:]
        uu_list = tl.ncFetch(sim,'stats','profiles', 'u_mean2')\
            [init_index:final_index][:]
        vv_list = tl.ncFetch(sim,'stats','profiles', 'v_mean2')\
            [init_index:final_index][:]
        
        uu = ensemble(uu_list)
        vv = ensemble(vv_list)
        ww_face = ensemble(ww_list)
        ww = np.interp(z, z_face, ww_face)

        w_list = tl.ncFetch(sim,'stats','profiles', 'w_mean')\
            [init_index:final_index][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'u_mean')\
            [init_index:final_index][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'v_mean')\
            [init_index:final_index][:]
        
        u = ensemble(u_list)
        v = ensemble(v_list)
        w_face = ensemble(w_list)
        w = np.interp(z, z_face, w_face)
        
        
    i=0; wvar= [0]*len(z); uvar= [0]*len(z); vvar= [0]*len(z);
    while (i<len(z)):
        wvar[i] = ww[i] - w[i]*w[i]
        uvar[i] = uu[i] - u[i]*u[i]
        vvar[i] = vv[i] - v[i]*v[i]
        i += 1
        
    return z, wvar, uvar, vvar


def vel_covariances(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation (snapshot).
    #         If ti>0 & tf<0, profile at t=ti (snapshot).
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    z_face = tl.ncFetch(sim,'stats','profiles', 'z')[:]
    if (ti<0 and tf<0):
        upvp = tl.ncFetch(sim,'stats','profiles', 'upvp_mean')[-1][:]
        upwp = tl.ncFetch(sim,'stats','profiles', 'upwp_mean')[-1][:]
        vpwp = tl.ncFetch(sim,'stats','profiles', 'vpwp_mean')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        upvp = tl.ncFetch(sim,'stats','profiles', 'upvp_mean')[index][:]
        upwp = tl.ncFetch(sim,'stats','profiles', 'upwp_mean')[index][:]
        vpwp = tl.ncFetch(sim,'stats','profiles', 'vpwp_mean')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        upvp_list = tl.ncFetch(sim,'stats','profiles', 'upvp_mean')\
            [init_index:final_index][:]
        upwp_list = tl.ncFetch(sim,'stats','profiles', 'upwp_mean')\
            [init_index:final_index][:]
        vpwp_list = tl.ncFetch(sim,'stats','profiles', 'vpwp_mean')\
            [init_index:final_index][:]
        
        upwp = ensemble(upwp_list)
        vpwp = ensemble(vpwp_list)
        upvp = ensemble(upvp_list)
        
    return z, upwp, vpwp, upvp

def tke(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # resolved TKE, obtained through postprocessing.
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    z, wvar, uvar, vvar = vel_variances(sim, ti, tf)
    
    i=0; tke = [0]*len(z)
    while(i<len(z)):
        tke[i]= 0.5*(uvar[i] + vvar[i] + wvar[i])
        i += 1
        
    return z, tke

def tke_sgs(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # sgs TKE, obtained online if TKE closure is used.
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        tke = tl.ncFetch(sim,'stats','profiles', 'e_mean')[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        tke = tl.ncFetch(sim,'stats','profiles', 'e_mean')[index][:]
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        tke_list = tl.ncFetch(sim,'stats','profiles', 'e_mean')\
            [init_index:final_index][:]
        
        tke = ensemble(tke_list)
            
    return z, tke

def tke_budget(sim, ti=-1, tf=-1):
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A')[-1][:]
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B')[-1][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D')[-1][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P')[-1][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T')[-1][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S')[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A')[index][:]
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B')[index][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D')[index][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P')[index][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T')[index][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S')[index][:]
        
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
    
        tke_a_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A')\
            [init_index:final_index][:]
        tke_b_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B')\
            [init_index:final_index][:]
        tke_d_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D')\
            [init_index:final_index][:]
        tke_p_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P')\
            [init_index:final_index][:]
        tke_t_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T')\
            [init_index:final_index][:]
        tke_s_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S')\
            [init_index:final_index][:]
            
        tke_a = ensemble(tke_a_list)
        tke_b = ensemble(tke_b_list)
        tke_d = ensemble(tke_d_list)
        tke_p = ensemble(tke_p_list)
        tke_t = ensemble(tke_t_list)
        tke_s = ensemble(tke_s_list)
        
    i=0; res = []
    while (i<len(tke_a)):
        res.append(-(tke_a[i] + tke_b[i] + tke_d[i] +
        tke_p[i] + tke_t[i] + tke_s[i]))
        i += 1
    return z, tke_a, tke_b, tke_d, tke_p, tke_t, tke_s, res

                    #Tracers#
                
def tke_budget_env(sim, ti=-1, tf=-1):
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_env')[-1][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_env')[-1][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_env')[-1][:]
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_env')[-1][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_env')[-1][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_env')[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_env')[index][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_env')[index][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_env')[index][:]
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_env')[index][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_env')[index][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_env')[index][:]
        
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
    
        tke_b_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_env')\
            [init_index:final_index][:]
        tke_t_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_env')\
            [init_index:final_index][:]
        tke_s_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_env')\
            [init_index:final_index][:]
        tke_a_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_env')\
            [init_index:final_index][:]
        tke_d_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_env')\
            [init_index:final_index][:]
        tke_p_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_env')\
            [init_index:final_index][:]
            
        tke_b = ensemble(tke_b_list)
        tke_t = ensemble(tke_t_list)
        tke_s = ensemble(tke_s_list)
        tke_a = ensemble(tke_a_list)
        tke_d = ensemble(tke_d_list)
        tke_p = ensemble(tke_p_list)

    return z, tke_a, tke_b, tke_d, tke_p, tke_t, tke_s

def tke_budget_upd(sim, ti=-1, tf=-1):
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_upd')[-1][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_upd')[-1][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_upd')[-1][:]
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_upd')[-1][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_upd')[-1][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_upd')[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_upd')[index][:]
        tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_upd')[index][:]
        tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_upd')[index][:]
        tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_upd')[index][:]
        tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_upd')[index][:]
        tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_upd')[index][:]
        
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
    
        tke_b_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B_upd')\
            [init_index:final_index][:]
        tke_t_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T_upd')\
            [init_index:final_index][:]
        tke_s_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S_upd')\
            [init_index:final_index][:]
        tke_a_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A_upd')\
            [init_index:final_index][:]
        tke_d_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D_upd')\
            [init_index:final_index][:]
        tke_p_list = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P_upd')\
            [init_index:final_index][:]
            
        tke_b = ensemble(tke_b_list)
        tke_t = ensemble(tke_t_list)
        tke_s = ensemble(tke_s_list)
        tke_a = ensemble(tke_a_list)
        tke_d = ensemble(tke_d_list)
        tke_p = ensemble(tke_p_list)

    return z, tke_a, tke_b, tke_d, tke_p, tke_t, tke_s

def updraft_variances(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        ww = tl.ncFetch(sim,'stats','profiles', 'updraft_w2')[-1][:]
        uu = tl.ncFetch(sim,'stats','profiles', 'updraft_u2')[-1][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'updraft_v2')[-1][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'updraft_w')[-1][:]
        u = tl.ncFetch(sim,'stats','profiles', 'updraft_u')[-1][:]
        v = tl.ncFetch(sim,'stats','profiles', 'updraft_v')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        ww = tl.ncFetch(sim,'stats','profiles', 'updraft_w2')[index][:]
        uu = tl.ncFetch(sim,'stats','profiles', 'updraft_u2')[index][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'updraft_v2')[index][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'updraft_w')[index][:]
        u = tl.ncFetch(sim,'stats','profiles', 'updraft_u')[index][:]
        v = tl.ncFetch(sim,'stats','profiles', 'updraft_v')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        ww_list = tl.ncFetch(sim,'stats','profiles', 'updraft_w2')\
            [init_index:final_index][:]
        uu_list = tl.ncFetch(sim,'stats','profiles', 'updraft_u2')\
            [init_index:final_index][:]
        vv_list = tl.ncFetch(sim,'stats','profiles', 'updraft_v2')\
            [init_index:final_index][:]
        
        uu = ensemble(uu_list)
        vv = ensemble(vv_list)
        ww = ensemble(ww_list)
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'updraft_w')\
            [init_index:final_index][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'updraft_u')\
            [init_index:final_index][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'updraft_v')\
            [init_index:final_index][:]
        
        u = ensemble(u_list)
        v = ensemble(v_list)
        w = ensemble(w_list)
        
        
    i=0; wvar= [0]*len(z); uvar= [0]*len(z); vvar= [0]*len(z);
    while (i<len(z)):
        wvar[i] = ww[i] - w[i]*w[i]
        uvar[i] = uu[i] - u[i]*u[i]
        vvar[i] = vv[i] - v[i]*v[i]
        i += 1
        
    return z, wvar, uvar, vvar

def env_variances(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        ww = tl.ncFetch(sim,'stats','profiles', 'env_w2')[-1][:]
        uu = tl.ncFetch(sim,'stats','profiles', 'env_u2')[-1][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'env_v2')[-1][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[-1][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[-1][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        ww = tl.ncFetch(sim,'stats','profiles', 'env_w2')[index][:]
        uu = tl.ncFetch(sim,'stats','profiles', 'env_u2')[index][:]
        vv = tl.ncFetch(sim,'stats','profiles', 'env_v2')[index][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[index][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[index][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        ww_list = tl.ncFetch(sim,'stats','profiles', 'env_w2')\
            [init_index:final_index][:]
        uu_list = tl.ncFetch(sim,'stats','profiles', 'env_u2')\
            [init_index:final_index][:]
        vv_list = tl.ncFetch(sim,'stats','profiles', 'env_v2')\
            [init_index:final_index][:]
        
        uu = ensemble(uu_list)
        vv = ensemble(vv_list)
        ww = ensemble(ww_list)
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'env_w')\
            [init_index:final_index][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'env_u')\
            [init_index:final_index][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'env_v')\
            [init_index:final_index][:]
        
        u = ensemble(u_list)
        v = ensemble(v_list)
        w = ensemble(w_list)
        
        
    i=0; wvar= [0]*len(z); uvar= [0]*len(z); vvar= [0]*len(z);
    while (i<len(z)):
        wvar[i] = ww[i] - w[i]*w[i]
        uvar[i] = uu[i] - u[i]*u[i]
        vvar[i] = vv[i] - v[i]*v[i]
        i += 1
        
    return z, wvar, uvar, vvar

def env_covariances(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Covariances are computed: <u'w'> = <uw> - <u><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        uw = tl.ncFetch(sim,'stats','profiles', 'env_uw')[-1][:]
        vw = tl.ncFetch(sim,'stats','profiles', 'env_vw')[-1][:]
        uv = tl.ncFetch(sim,'stats','profiles', 'env_uv')[-1][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[-1][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[-1][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        uw = tl.ncFetch(sim,'stats','profiles', 'env_uw')[index][:]
        vw = tl.ncFetch(sim,'stats','profiles', 'env_vw')[index][:]
        uv = tl.ncFetch(sim,'stats','profiles', 'env_uv')[index][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[index][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[index][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        uw_list = tl.ncFetch(sim,'stats','profiles', 'env_uw')\
            [init_index:final_index][:]
        vw_list = tl.ncFetch(sim,'stats','profiles', 'env_vw')\
            [init_index:final_index][:]
        uv_list = tl.ncFetch(sim,'stats','profiles', 'env_uv')\
            [init_index:final_index][:]
        
        uw = ensemble(uw_list)
        vw = ensemble(vw_list)
        uv = ensemble(uv_list)
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'env_w')\
            [init_index:final_index][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'env_u')\
            [init_index:final_index][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'env_v')\
            [init_index:final_index][:]
        
        u = ensemble(u_list)
        v = ensemble(v_list)
        w = ensemble(w_list)
        
        
    i=0; uwcovar= [0]*len(z); vwcovar= [0]*len(z); uvcovar= [0]*len(z);
    while (i<len(z)):
        uwcovar[i] = uw[i] - u[i]*w[i]
        vwcovar[i] = vw[i] - v[i]*w[i]
        uvcovar[i] = uv[i] - u[i]*v[i]
        i += 1
        
    return z, uwcovar, vwcovar, uvcovar

def ent_det_from_upd(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Covariances are computed: <u'w'> = <uw> - <u><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    alpha0 = tl.ncFetch(sim,'stats','reference', 'alpha0_half')[:]
    if (ti<0 and tf<0):
        uw = tl.ncFetch(sim,'stats','profiles', 'env_uw')[-1][:]
        vw = tl.ncFetch(sim,'stats','profiles', 'env_vw')[-1][:]
        uv = tl.ncFetch(sim,'stats','profiles', 'env_uv')[-1][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[-1][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[-1][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[-1][:]
        
            
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        uw = tl.ncFetch(sim,'stats','profiles', 'env_uw')[index][:]
        vw = tl.ncFetch(sim,'stats','profiles', 'env_vw')[index][:]
        uv = tl.ncFetch(sim,'stats','profiles', 'env_uv')[index][:]
        
        w = tl.ncFetch(sim,'stats','profiles', 'env_w')[index][:]
        u = tl.ncFetch(sim,'stats','profiles', 'env_u')[index][:]
        v = tl.ncFetch(sim,'stats','profiles', 'env_v')[index][:]
    
            
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))

        uw_list = tl.ncFetch(sim,'stats','profiles', 'env_uw')\
            [init_index:final_index][:]
        vw_list = tl.ncFetch(sim,'stats','profiles', 'env_vw')\
            [init_index:final_index][:]
        uv_list = tl.ncFetch(sim,'stats','profiles', 'env_uv')\
            [init_index:final_index][:]
        
        uw = ensemble(uw_list)
        vw = ensemble(vw_list)
        uv = ensemble(uv_list)
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'env_w')\
            [init_index:final_index][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'env_u')\
            [init_index:final_index][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'env_v')\
            [init_index:final_index][:]
        
        u = ensemble(u_list)
        v = ensemble(v_list)
        w = ensemble(w_list)
        
        
    i=0; uwcovar= [0]*len(z); vwcovar= [0]*len(z); uvcovar= [0]*len(z);
    while (i<len(z)):
        uwcovar[i] = uw[i] - u[i]*w[i]
        vwcovar[i] = vw[i] - v[i]*w[i]
        uvcovar[i] = uv[i] - u[i]*v[i]
        i += 1
        
    return z, uwcovar, vwcovar, uvcovar


def variances_wtime(sim, z0, domain):
    # Instantaneous or time-averaged horizontal average of
    # variances (centered second moments) of resolved 
    # velocity profile with z 
    # (substracting geostrophic forcing).
    
    # Variances are computed: <w'w'> = <ww> - <w><w>
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, profile at end of simulation.
    #         If ti>0 & tf<0, profile at t=ti.
    #         If ti>0 & tf>0, time-average of profile over [ti, tf]
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    dz = z[1]-z[0]
    index = int(round((z0)/dz))
    t = tl.ncFetch(sim,'stats','profiles', 't')[:]
    if domain=='env':
        ww_list = tl.ncFetch(sim,'stats','profiles', 'env_w2')[:][:]
        uu_list = tl.ncFetch(sim,'stats','profiles', 'env_u2')[:][:]
        vv_list = tl.ncFetch(sim,'stats','profiles', 'env_v2')[:][:]
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'env_w')[:][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'env_u')[:][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'env_v')[:][:]
    elif domain=='upd':
        ww_list = tl.ncFetch(sim,'stats','profiles', 'updraft_w2')[:][:]
        uu_list = tl.ncFetch(sim,'stats','profiles', 'updraft_u2')[:][:]
        vv_list = tl.ncFetch(sim,'stats','profiles', 'updraft_v2')[:][:]
        
        w_list = tl.ncFetch(sim,'stats','profiles', 'updraft_w')[:][:]
        u_list = tl.ncFetch(sim,'stats','profiles', 'updraft_u')[:][:]
        v_list = tl.ncFetch(sim,'stats','profiles', 'updraft_v')[:][:]
    else:
        print('error')
        
    i=0; wvar= [0]*len(t); uvar= [0]*len(t); vvar= [0]*len(t);
    while (i<len(t)):
        wvar[i] = ww_list[i][index] - w_list[i][index]*w_list[i][index]
        uvar[i] = uu_list[i][index] - u_list[i][index]*u_list[i][index]
        vvar[i] = vv_list[i][index] - v_list[i][index]*v_list[i][index]
        i += 1
        
    return t, wvar, uvar, vvar

def tke_budget_wtime(sim):
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]

    tke_a = tl.ncFetch(sim,'stats','profiles', 'tke_prod_A')[:][:]
    tke_b = tl.ncFetch(sim,'stats','profiles', 'tke_prod_B')[:][:]
    tke_d = tl.ncFetch(sim,'stats','profiles', 'tke_prod_D')[:][:]
    tke_p = tl.ncFetch(sim,'stats','profiles', 'tke_prod_P')[:][:]
    tke_t = tl.ncFetch(sim,'stats','profiles', 'tke_prod_T')[:][:]
    tke_s = tl.ncFetch(sim,'stats','profiles', 'tke_prod_S')[:][:]
        
    i=0; 
    res = np.zeros_like(tke_a)
    for i in range(len(tke_a)):
        res[i] = np.multiply(np.add(np.add(np.add(np.add(np.add(tke_a[i], tke_b[i]), tke_d[i]), 
           tke_p[i]), tke_t[i]), tke_s[i]), -1.0)
    return z, tke_a, tke_b, tke_d, tke_p, tke_t, tke_s, res

def potempProf(sim, ti=-1, tf=-1):
    # Instantaneous or time-averaged horizontally-averaged 
    #  potential temperature profile with z.
    
    # Input: Simulation, init. time and final time of averaging.
    
    # Output: If ti= -1 & tf= -1, pot. temp. profile at end of simulation.
    #         If ti>0 & tf<0, pot. temp. profile at t=ti.
    #         If ti>0 & tf>0, time-average of pot. temp. profile over [ti, tf]
    
    z = tl.ncFetch(sim,'stats','profiles', 'z_half')[:]
    if (ti<0 and tf<0):
        potemp = tl.ncFetch(sim,'stats', 'profiles', 'theta_mean')[-1][:]
    elif (ti>0 and tf<0):
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        index = int(round((ti-t[0])/dt) + 1)
        potemp = tl.ncFetch(sim,'stats', 'profiles', 'theta_mean')[index][:]
    else: 
        t = tl.ncFetch(sim,'stats','profiles', 't')[:]
        dt = t[1]-t[0]
        init_index = int(round((ti-t[0])/dt) + 1)
        final_index = int(round((tf-t[0])/dt))
    
        potemp_list = tl.ncFetch(sim,'stats','profiles', 'theta_mean')\
            [init_index:final_index][:]
            
        potemp = ensemble(potemp_list)
    return potemp, z